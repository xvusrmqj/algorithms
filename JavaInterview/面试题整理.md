# 【JAVA基础】
## 多线程 
1. volatile关键字
 答: 
* 线程不安全的原因 :
 一个对象线程不安全的原因包括:共享和可变. 共享指该对象是可以同多个线程访问的. 可变是指变量的值在生命周期中可以变化. 
* 解决方法:
	1. 不在线程之间共享变量
	2. 将变量修改为不可变
	3. 在访问变量时使用同步
* 如何同步:
 JAVA提供的同步机制包括：synchronized关键字,显式锁,volatile关键字,原子变量.
* 操作的原子性和内存的可见性
	- 操作的原子性: 防止某对象使用的同时别的线程对其进行修改. 
	- 内存的可见性: 变量被一个线程修改后其他线程立即可见
 	注:加锁机制两者都保证了, 而volatile只保证了内存的可见性.
*什么时候使用volatile?
满足以下所有条件时,才应该使用volatile.
	1. 对变量的写入不依赖当前值,或者能确保只有一个线程更新变量的值
	2. 该变量不会与其他状态变量一起纳入不变性条件中.
	3. 在访问变量时不需要加锁

2. 锁的优化策略
 答:
  ① 读写分离
	② 分段加锁
	③ 减少锁持有的时间
	④ 多个线程尽量以相同的顺序去获取资源
	比如不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。
	
3. "equals" VS "==" VS "hashCode"
 答: 
* ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是
否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。

* 如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆
内存），变量也占用一块内存，例如` Objet obj = new Object();`变量 obj 是一个内存， new Object()是另一个内
存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。

* equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较
的两个对象是独立的。例如，对于下面的代码：
```
	String a=new String("foo");
	String b=new String("foo");
```
两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个不同的对
象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式 a==b 将返回 false，而这
两个对象中的内容是相同的，所以，表达式 a.equals(b)将返回 true。

* 如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）就是使
用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals 和使用==会得到同样的
结果，如果比较的是两个独立的对象则总返回 false。

4. 如何设置一个不可变类
 答:
 4.1 什么是不可变类？
 	答：类的属性是不可变的类。
 4.2 如何设计不可变类？
	答：1. 使用private final修饰类属性.
		2. 使用带参构造器初始化属性. 如果该属性是可变类型,用可变类型的属性拷贝的方式来初始化.
 


# 【JVM】
 1. JVM调优
 1.	内存泄漏与内存溢出的区别。
答：内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java 中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们 new 了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露，内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限 。
 2.	谈谈JAVA内存分区。
答：Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区1。

 1)	程序计数器：一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。
 
2)	Java 虚拟机栈：该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。
a)	局部变量表：局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型（boolean、byte, char, short, int, float, long, double）、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）。
b)	操作数栈：又常被称为操作栈，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。
c)	动态连接：每个栈帧都包含一个指向运行时常量池（在方法区中）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
d)	方法返回地址：一般来说，方法正常退出时，调用者的 PC 计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。

3)	本地方法栈：该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

4)	JAVA堆：Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

5)	方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java 虚拟机规范把方法区描述为 Java 堆的一个逻辑部分，而且它和 Java Heap 一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。

6)	直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。
 
# 【算法】
 1. 是否了解动态规划
 
#【设计模式】
1. 什么是回调方法，java中如何实现回调？

## 职责链模式（设计模式）
## 单例模式、
## 简单工厂模式、
## 工厂模式、
## 抽象工厂模式、
## 策略模式、
## 观察者模式、
## 组合模式、
## 适配器模式、
## 装饰模式、
## 代理模式、
## 外观模式。
 
# 【数据库】
1. 实践中如何优化MySQL
2. NoSQL, key-value存储原理
3. sql注入
4. MySQL引擎
5. 数据库存储引擎的原理
5. 分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。
6. varchar和text底层实现的区别

# 【计算机网络】
1. TCP为什么是4次挥手和3次握手？
2. 

# 【实际应用】
 1. 我项目中使用的单机服务器，如果将它部署成分布式服务器？
 2. 分布式系统之CAP理论
 3. 如何保证cache服务器和数据库服务器一致性
 4. 一个是有个十亿ip记录的文件，找出访问次数最多的十个.
 5. 第二个是ip归属地查询思路
